/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes rapid prototyping by focusing on strict authentication and authorization, while relaxing data validation constraints. It enforces user-based ownership for blog posts, ensuring that only the author can modify or delete their own content. Data validation is intentionally minimal to allow for flexible schema evolution during the early stages of development.
 *
 * Data Structure:
 * The primary data resides in the `/blog_posts/{postId}` collection, where each document represents a single blog post. Each blog post contains metadata like title, content, authorId, authorName, category, isPublished, createdAt, and updatedAt.
 *
 * Key Security Decisions:
 * - Public Read Access: Blog posts are publicly readable (`get`, `list`) to facilitate broad content consumption.
 * - Owner-Only Writes: Only the author of a blog post can create, update, or delete it. This is enforced using the `authorId` field within the document.
 * - Relaxed Data Validation: During prototyping, data type and presence validation are minimized to allow for faster iteration on the data model. Only fields critical for authorization are validated.
 *
 * Denormalization for Authorization:
 * The `authorId` field is denormalized directly into the `/blog_posts/{postId}` documents. This enables efficient owner-only write rules without requiring additional database reads.
 *
 * Structural Segregation:
 * The `isPublished` field controls the visibility of blog posts. This approach allows for easy management of draft and published content within the same collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read blog posts, but restricts creation, updates, and deletion to the author.
     * @path /blog_posts/{postId}
     * @allow (get, list) - Any user can read blog posts.
     * @allow (create) - User can create a blog post if the authorId matches their UID.
     * @allow (update, delete) - The author can update/delete their blog post.
     * @deny (create) - A user cannot create a blog post with an authorId that doesn't match their UID.
     * @deny (update, delete) - A user cannot update/delete someone else's blog post.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /blog_posts/{postId} {
      // Allow anyone to read blog posts
      allow get, list: if true;

      // Only allow the author to create, update, and delete blog posts
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the document.
     * @param {string} userId - The user ID to compare against the authenticated user's ID.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the document, and that the document exists.
     * @param {string} userId - The user ID to compare against the authenticated user's ID.
     * @return {bool} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}